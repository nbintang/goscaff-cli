package auth

import (
	"context"
	"{{.MODULE_PATH}}/internal/enums"
	"{{.MODULE_PATH}}/internal/infra/email"
	"{{.MODULE_PATH}}/internal/infra/token"
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/redis/go-redis/v9"
)

func (s *authServiceImpl) generateTokens(ctx context.Context, id string, email string, role enums.EUserRoleType) (TokensResponseDto, error) {
	accessTTL := 15 * time.Minute
	refreshTTL := 24 * time.Hour
	accessJTI := uuid.NewString()
	accessExpUnix := time.Now().Add(accessTTL).Unix()
	accessToken, err := s.tokenService.GenerateToken(&token.GenerateTokenParams{
		ID: id, Email: email, Role: enums.EUserRoleType(role), JTI: accessJTI,
		Type: enums.TokenAccess}, s.env.JWTAccessSecret, accessTTL,
	)

	if err != nil {
		return TokensResponseDto{}, err
	}
	refreshJTI := uuid.NewString()
	refreshToken, err := s.tokenService.GenerateToken(&token.GenerateTokenParams{
		ID: id, Email: email, Role: enums.EUserRoleType(role), JTI: refreshJTI,
		Type: enums.TokenRefresh}, s.env.JWTRefreshSecret, refreshTTL,
	)
	if err != nil {
		return TokensResponseDto{}, err
	}

	if err := s.cacheService.Set(ctx, keyRTAccess+refreshJTI, id, refreshTTL); err != nil {
		return TokensResponseDto{}, err
	}
	if err := s.cacheService.Set(ctx, keyRTAccess+refreshJTI, accessJTI, refreshTTL); err != nil {
		s.cacheService.Del(ctx, keyRefresh+refreshJTI)
		return TokensResponseDto{}, err
	}
	if err := s.cacheService.Set(ctx, keyRTAccessExp+refreshJTI, accessExpUnix, refreshTTL); err != nil {
		s.cacheService.Del(ctx, keyRefresh+refreshJTI, keyRTAccess+refreshJTI)
		return TokensResponseDto{}, err
	}
	if err := s.cacheService.SAdd(ctx, keyUserTokens+id, refreshJTI, refreshTTL); err != nil {
		s.cacheService.Del(ctx,
			keyRefresh+refreshJTI,
			keyRTAccess+refreshJTI,
			keyRTAccessExp+refreshJTI,
		)
		return TokensResponseDto{}, err
	}
	return TokensResponseDto{AccessToken: accessToken, RefreshToken: refreshToken}, nil
}

func (s *authServiceImpl) generateVerificationToken(id string) (string, error) {
	return s.tokenService.GenerateToken(&token.GenerateTokenParams{
		ID: id,
	},
		s.env.JWTVerificationSecret,
		3*time.Minute,
	)
}

func (s *authServiceImpl) revokeAllUserTokens(ctx context.Context, userID string) error {
	userTokensKey := keyUserTokens + userID
	rtJTIs, err := s.cacheService.SMembers(ctx, userTokensKey)
	if err != nil {
		if err == redis.Nil {
			return nil
		}
		return err
	}
	for _, rtJTI := range rtJTIs {
		s.blacklistAccessByRefreshJTI(ctx, rtJTI)
		s.cacheService.Del(ctx,
			keyRefresh+rtJTI,
			keyRTAccess+rtJTI,
			keyRTAccessExp+rtJTI,
		)
	}
	s.cacheService.Del(ctx, userTokensKey)
	s.logger.Infof("revoke all tokens for user : %s", userID)
	return nil
}

func (s *authServiceImpl) blacklistAccessByRefreshJTI(ctx context.Context, rtJTI string) error {
	accessJTI, err := s.cacheService.Get(ctx, keyRTAccess+rtJTI)
	if err != nil {
		if err != redis.Nil {
			s.logger.Warnf("failed get rt_access for %s: %v", rtJTI, err)
		}
		return nil
	}
	if accessJTI == "" {
		return nil
	}

	expStr, err := s.cacheService.Get(ctx, keyRTAccessExp+rtJTI)
	if err != nil {
		if err != redis.Nil {
			s.logger.Warnf("failed get rt_access_exp for %s: %v", rtJTI, err)
		}
		return nil
	}

	expUnix, _ := strconv.ParseInt(expStr, 10, 64)
	ttl := time.Until(time.Unix(expUnix, 0))
	if ttl <= 0 {
		return nil
	}

	return s.cacheService.Set(ctx, keyBLAccess+accessJTI, "1", ttl)
}

func (s *authServiceImpl) sendEmail(emailAddr, subject, messsage string) {
	emailCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	if err := s.emailService.SendEmail(emailCtx, email.Params{
		Subject: subject,
		Message: messsage,
		Reciever: email.Reciever{
			Email: emailAddr,
		}}); err != nil {
		s.logger.Error(err)
	}
}